<!--
This file was generated by Spark. Do not edit it by hand.
-->
# DSL: Reactor.Dsl



## reactor
The top-level reactor DSL

### Nested DSLs
 * [around](#reactor-around)
   * argument
   * wait_for
 * [collect](#reactor-collect)
   * argument
   * wait_for
 * [compose](#reactor-compose)
   * argument
   * wait_for
 * [debug](#reactor-debug)
   * argument
   * wait_for
 * [group](#reactor-group)
   * argument
   * wait_for
 * [input](#reactor-input)
 * [step](#reactor-step)
   * argument
   * wait_for
 * [switch](#reactor-switch)
   * matches?

   * default






### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-return" href="#reactor-return">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        return
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Specify which step result to return upon completion.

  </td>
</tr>

  </tbody>
</table>



## reactor.around
```elixir
around name, fun \ nil
```


Wrap a function around a group of steps.


### Nested DSLs
 * [argument](#reactor-around-argument)
 * [wait_for](#reactor-around-wait_for)




### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-around-name" href="#reactor-around-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name of the group of steps.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-around-fun" href="#reactor-around-fun">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        fun
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The around function. See `Reactor.Step.Around` for more information.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-around-allow_async?" href="#reactor-around-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">false</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

  </tbody>
</table>


## reactor.around.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-around-argument-name" href="#reactor-around-argument-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-around-argument-source" href="#reactor-around-argument-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-around-argument-transform" href="#reactor-around-argument-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.around.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-around-wait_for-names" href="#reactor-around-wait_for-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom | list(atom)</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Around`

## reactor.collect
```elixir
collect name
```


A Reactor step which simply collects and returns it's arguments.

Arguments can optionally be transformed before returning.


### Nested DSLs
 * [argument](#reactor-collect-argument)
 * [wait_for](#reactor-collect-wait_for)


### Examples
```
collect :latest_release_uri do
  argument :repository, input(:repository)
  argument :organisation, input(:organisation)

  transform fn inputs ->
    %{uri: "https://api.github.com/repos/#{inputs.organisation}/#{inputs.repository}/releases/latest"}
  end
end

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-collect-name" href="#reactor-collect-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-collect-transform" href="#reactor-collect-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the entire argument map before it is returned.

  </td>
</tr>

  </tbody>
</table>


## reactor.collect.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-collect-argument-name" href="#reactor-collect-argument-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-collect-argument-source" href="#reactor-collect-argument-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-collect-argument-transform" href="#reactor-collect-argument-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.collect.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-collect-wait_for-names" href="#reactor-collect-wait_for-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom | list(atom)</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Collect`

## reactor.compose
```elixir
compose name, reactor
```


Compose another Reactor into this one.

Allows place another Reactor into this one as if it were a single step.


### Nested DSLs
 * [argument](#reactor-compose-argument)
 * [wait_for](#reactor-compose-wait_for)




### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-compose-name" href="#reactor-compose-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the step. Allows the result of the composed reactor to be depended upon by steps in this reactor.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-compose-reactor" href="#reactor-compose-reactor">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        reactor
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor | module</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The reactor module or struct to compose upon.

  </td>
</tr>

  </tbody>
</table>



## reactor.compose.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-compose-argument-name" href="#reactor-compose-argument-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-compose-argument-source" href="#reactor-compose-argument-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-compose-argument-transform" href="#reactor-compose-argument-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.compose.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-compose-wait_for-names" href="#reactor-compose-wait_for-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom | list(atom)</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Compose`

## reactor.debug
```elixir
debug name
```


Inserts a step which will send debug information to the `Logger`.


### Nested DSLs
 * [argument](#reactor-debug-argument)
 * [wait_for](#reactor-debug-wait_for)


### Examples
```
debug :debug do
  argument :suss, result(:suss_step)
end

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-debug-name" href="#reactor-debug-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique identifier for the step.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-debug-level" href="#reactor-debug-level">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        level
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">:emergency | :alert | :critical | :error | :warning | :notice | :info | :debug</code>
  </td>
  <td style="text-align: left">
    <code class="inline">:debug</code>
  </td>
  <td style="text-align: left" colspan=2>
    The log level to send the debug information to.

  </td>
</tr>

  </tbody>
</table>


## reactor.debug.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-debug-argument-name" href="#reactor-debug-argument-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-debug-argument-source" href="#reactor-debug-argument-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-debug-argument-transform" href="#reactor-debug-argument-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.debug.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-debug-wait_for-names" href="#reactor-debug-wait_for-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom | list(atom)</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Debug`

## reactor.group
```elixir
group name
```


Call functions before and after a group of steps.


### Nested DSLs
 * [argument](#reactor-group-argument)
 * [wait_for](#reactor-group-wait_for)




### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-group-name" href="#reactor-group-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the group of steps.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-group-before_all" href="#reactor-group-before_all">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        before_all
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The before function. See `Reactor.Step.Group` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-group-after_all" href="#reactor-group-after_all">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        after_all
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The after function. See `Reactor.Step.Group` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-group-allow_async?" href="#reactor-group-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

  </tbody>
</table>


## reactor.group.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-group-argument-name" href="#reactor-group-argument-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-group-argument-source" href="#reactor-group-argument-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-group-argument-transform" href="#reactor-group-argument-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.group.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-group-wait_for-names" href="#reactor-group-wait_for-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom | list(atom)</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Group`

## reactor.input
```elixir
input name
```


Specifies an input to the Reactor.

An input is a value passed in to the Reactor when executing.
If a Reactor were a function, these would be it's arguments.

Inputs can be transformed with an arbitrary function before being passed
to any steps.




### Examples
```
input :name

```

```
input :age do
  transform &String.to_integer/1
end

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-input-name" href="#reactor-input-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for this input. Used to allow steps to depend on it.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-input-transform" href="#reactor-input-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the input before it is passed to any steps.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Input`

## reactor.step
```elixir
step name, impl \ nil
```


Specifies a Reactor step.

Steps are the unit of work in a Reactor.  Reactor will calculate the
dependencies graph between the steps and execute as many as it can in each
iteration.

See the `Reactor.Step` behaviour for more information.


### Nested DSLs
 * [argument](#reactor-step-argument)
 * [wait_for](#reactor-step-wait_for)


### Examples
```
step :create_user, MyApp.Steps.CreateUser do
  argument :username, input(:username)
  argument :password_hash, result(:hash_password)
end

```

```
step :hash_password do
  argument :password, input(:password)

  run fn %{password: password}, _ ->
    {:ok, Bcrypt.hash_pwd_salt(password)}
  end
end

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-step-name" href="#reactor-step-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-step-impl" href="#reactor-step-impl">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        impl
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A module that implements the `Reactor.Step` behaviour that provides the implementation.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-step-run" href="#reactor-step-run">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        run
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa | (any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Provide an anonymous function which implements the `run/3` callback. Cannot be provided at the same time as the `impl` argument.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-step-undo" href="#reactor-step-undo">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        undo
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa | (any, any -> any) | mfa | (any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-step-compensate" href="#reactor-step-compensate">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        compensate
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa | (any, any -> any) | mfa | (any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-step-max_retries" href="#reactor-step-max_retries">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        max_retries
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">:infinity | non_neg_integer</code>
  </td>
  <td style="text-align: left">
    <code class="inline">:infinity</code>
  </td>
  <td style="text-align: left" colspan=2>
    The maximum number of times that the step can be retried before failing. Only used when the result of the `compensate/4` callback is `:retry`.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-step-async?" href="#reactor-step-async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-step-transform" href="#reactor-step-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the entire argument map before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>


## reactor.step.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-step-argument-name" href="#reactor-step-argument-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-step-argument-source" href="#reactor-step-argument-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-step-argument-transform" href="#reactor-step-argument-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.step.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-step-wait_for-names" href="#reactor-step-wait_for-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom | list(atom)</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Step`

## reactor.switch
```elixir
switch name
```


Use a predicate to determine which steps should be executed.


### Nested DSLs
 * [matches?](#reactor-switch-matches?)

 * [default](#reactor-switch-default)





### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-switch-name" href="#reactor-switch-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the switch.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-switch-on" href="#reactor-switch-on">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        on
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The value to match against.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-switch-allow_async?" href="#reactor-switch-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

  </tbody>
</table>


## reactor.switch.matches?
```elixir
matches? predicate
```


A group of steps to run when the predicate matches.






### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-switch-matches?-predicate" href="#reactor-switch-matches?-predicate">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        predicate
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A one-arity function which is used to match the switch input. If the switch returns a truthy value, then the nested steps will be run.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-switch-matches?-allow_async?" href="#reactor-switch-matches?-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reactor-switch-matches?-return" href="#reactor-switch-matches?-return">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        return
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Specify which step result to return upon completion.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Switch.Match`

## reactor.switch.default


If none of the `matches?` branches match the input, then the `default`
steps will be run if provided.







### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-switch-default-return" href="#reactor-switch-default-return">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        return
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Specify which step result to return upon completion.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Switch.Default`




### Introspection

Target: `Reactor.Dsl.Switch`




