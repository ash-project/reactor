# DSL: Reactor.Dsl



## reactor
The top-level reactor DSL

### Nested DSLs
 * [around](#reactor-around)
   * argument
   * wait_for
 * [collect](#reactor-collect)
   * argument
   * wait_for
 * [compose](#reactor-compose)
   * argument
   * wait_for
 * [debug](#reactor-debug)
   * argument
   * wait_for
 * [group](#reactor-group)
   * argument
   * wait_for
 * [input](#reactor-input)
 * [step](#reactor-step)
   * argument
   * wait_for
 * [switch](#reactor-switch)
   * matches?

   * default






### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `return` | `atom` |  | Specify which step result to return upon completion. |



## reactor.around
```elixir
around name, fun \ nil
```


Wrap a function around a group of steps.


### Nested DSLs
 * [argument](#reactor-around-argument)
 * [wait_for](#reactor-around-wait_for)




### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique name of the group of steps. |
| `fun`* | `(any, any, any, any -> any) \| mfa` |  | The around function. See `Reactor.Step.Around` for more information. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `allow_async?` | `boolean` | `false` | Whether the emitted steps should be allowed to run asynchronously. |


## reactor.around.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| `source`* | `Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.around.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `names`* | `list(atom) \| atom` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Around`

## reactor.collect
```elixir
collect name
```


A Reactor step which simply collects and returns it's arguments.

Arguments can optionally be transformed before returning.


### Nested DSLs
 * [argument](#reactor-collect-argument)
 * [wait_for](#reactor-collect-wait_for)


### Examples
```
collect :latest_release_uri do
  argument :repository, input(:repository)
  argument :organisation, input(:organisation)

  transform fn inputs ->
    %{uri: "https://api.github.com/repos/#{inputs.organisation}/#{inputs.repository}/releases/latest"}
  end
end

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the entire argument map before it is returned. |


## reactor.collect.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| `source`* | `Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.collect.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `names`* | `list(atom) \| atom` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Collect`

## reactor.compose
```elixir
compose name, reactor
```


Compose another Reactor into this one.

Allows place another Reactor into this one as if it were a single step.


### Nested DSLs
 * [argument](#reactor-compose-argument)
 * [wait_for](#reactor-compose-wait_for)




### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique name for the step. Allows the result of the composed reactor to be depended upon by steps in this reactor. |
| `reactor`* | `Reactor \| module` |  | The reactor module or struct to compose upon. |



## reactor.compose.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| `source`* | `Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.compose.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `names`* | `list(atom) \| atom` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Compose`

## reactor.debug
```elixir
debug name
```


Inserts a step which will send debug information to the `Logger`.


### Nested DSLs
 * [argument](#reactor-debug-argument)
 * [wait_for](#reactor-debug-wait_for)


### Examples
```
debug :debug do
  argument :suss, result(:suss_step)
end

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique identifier for the step. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `level` | `:emergency \| :alert \| :critical \| :error \| :warning \| :notice \| :info \| :debug` | `:debug` | The log level to send the debug information to. |


## reactor.debug.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| `source`* | `Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.debug.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `names`* | `list(atom) \| atom` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Debug`

## reactor.group
```elixir
group name
```


Call functions before and after a group of steps.


### Nested DSLs
 * [argument](#reactor-group-argument)
 * [wait_for](#reactor-group-wait_for)




### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique name for the group of steps. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `before_all`* | `(any, any, any -> any) \| mfa` |  | The before function. See `Reactor.Step.Group` for more information. |
| `after_all`* | `(any, any, any -> any) \| mfa` |  | The after function. See `Reactor.Step.Group` for more information. |
| `allow_async?` | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |


## reactor.group.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| `source`* | `Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.group.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `names`* | `list(atom) \| atom` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Group`

## reactor.input
```elixir
input name
```


Specifies an input to the Reactor.

An input is a value passed in to the Reactor when executing.
If a Reactor were a function, these would be it's arguments.

Inputs can be transformed with an arbitrary function before being passed
to any steps.




### Examples
```
input :name

```

```
input :age do
  transform &String.to_integer/1
end

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique name for this input. Used to allow steps to depend on it. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the input before it is passed to any steps. |





### Introspection

Target: `Reactor.Dsl.Input`

## reactor.step
```elixir
step name, impl \ nil
```


Specifies a Reactor step.

Steps are the unit of work in a Reactor.  Reactor will calculate the
dependencies graph between the steps and execute as many as it can in each
iteration.

See the `Reactor.Step` behaviour for more information.


### Nested DSLs
 * [argument](#reactor-step-argument)
 * [wait_for](#reactor-step-wait_for)


### Examples
```
step :create_user, MyApp.Steps.CreateUser do
  argument :username, input(:username)
  argument :password_hash, result(:hash_password)
end

```

```
step :hash_password do
  argument :password, input(:password)

  run fn %{password: password}, _ ->
    {:ok, Bcrypt.hash_pwd_salt(password)}
  end
end

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps. |
| `impl` | `module \| nil` |  | A module that implements the `Reactor.Step` behaviour that provides the implementation. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `run` | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide an anonymous function which implements the `run/3` callback. Cannot be provided at the same time as the `impl` argument. |
| `undo` | `(any -> any) \| mfa \| (any, any -> any) \| mfa \| (any, any, any -> any) \| mfa` |  | Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument. |
| `compensate` | `(any -> any) \| mfa \| (any, any -> any) \| mfa \| (any, any, any -> any) \| mfa` |  | Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument. |
| `max_retries` | `:infinity \| non_neg_integer` | `:infinity` | The maximum number of times that the step can be retried before failing. Only used when the result of the `compensate/4` callback is `:retry`. |
| `async?` | `boolean` | `true` | When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`. |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the entire argument map before it is passed to the step. |


## reactor.step.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| `source`* | `Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `transform` | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.step.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `names`* | `list(atom) \| atom` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Step`

## reactor.switch
```elixir
switch name
```


Use a predicate to determine which steps should be executed.


### Nested DSLs
 * [matches?](#reactor-switch-matches?)

 * [default](#reactor-switch-default)





### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `name`* | `atom` |  | A unique name for the switch. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `on`* | `Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The value to match against. |
| `allow_async?` | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |


## reactor.switch.matches?
```elixir
matches? predicate
```


A group of steps to run when the predicate matches.






### Arguments
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `predicate`* | `(any -> any) \| mfa` |  | A one-arity function which is used to match the switch input. If the switch returns a truthy value, then the nested steps will be run. |
### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `allow_async?` | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |
| `return` | `atom` |  | Specify which step result to return upon completion. |





### Introspection

Target: `Reactor.Dsl.Switch.Match`

## reactor.switch.default


If none of the `matches?` branches match the input, then the `default`
steps will be run if provided.







### Options
| Name | Type | Default | Docs |
| ---  | ---  | ---     | ---  |
| `return` | `atom` |  | Specify which step result to return upon completion. |





### Introspection

Target: `Reactor.Dsl.Switch.Default`




### Introspection

Target: `Reactor.Dsl.Switch`




