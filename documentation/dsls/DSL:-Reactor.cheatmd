<!--
This file was generated by Spark. Do not edit it by hand.
-->
# DSL: Reactor.Dsl



## reactor
The top-level reactor DSL

### Nested DSLs
 * [around](#reactor-around)
   * argument
   * wait_for
 * [collect](#reactor-collect)
   * argument
   * wait_for
 * [compose](#reactor-compose)
   * argument
   * wait_for
 * [debug](#reactor-debug)
   * argument
   * wait_for
 * [group](#reactor-group)
   * argument
   * wait_for
 * [input](#reactor-input)
 * [iterate](#reactor-iterate)
   * argument
   * wait_for
   * for_each
   * map

   * reduce
   * source
 * [step](#reactor-step)
   * argument
   * wait_for
 * [switch](#reactor-switch)
   * matches?

   * default






### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="reactor-return" href="#reactor-return">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        return
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Specify which step result to return upon completion.

  </td>
</tr>

  </tbody>
</table>



## reactor.around
```elixir
around name, fun \ nil
```


Wrap a function around a group of steps.


### Nested DSLs
 * [argument](#reactor-around-argument)
 * [wait_for](#reactor-around-wait_for)





### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-fun-name" href="#name-fun-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name of the group of steps.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-fun-fun" href="#name-fun-fun">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        fun
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The around function. See `Reactor.Step.Around` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-fun-allow_async?" href="#name-fun-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">false</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

  </tbody>
</table>


## reactor.around.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-source-name" href="#name-source-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-source" href="#name-source-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-transform" href="#name-source-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.around.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="names-names" href="#names-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">list(atom) | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Around`

## reactor.collect
```elixir
collect name
```


A Reactor step which simply collects and returns it's arguments.

Arguments can optionally be transformed before returning.


### Nested DSLs
 * [argument](#reactor-collect-argument)
 * [wait_for](#reactor-collect-wait_for)


### Examples
```
collect :latest_release_uri do
  argument :repository, input(:repository)
  argument :organisation, input(:organisation)

  transform fn inputs ->
    %{uri: "https://api.github.com/repos/#{inputs.organisation}/#{inputs.repository}/releases/latest"}
  end
end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-name" href="#name-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-transform" href="#name-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the entire argument map before it is returned.

  </td>
</tr>

  </tbody>
</table>


## reactor.collect.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-source-name" href="#name-source-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-source" href="#name-source-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-transform" href="#name-source-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.collect.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="names-names" href="#names-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">list(atom) | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Collect`

## reactor.compose
```elixir
compose name, reactor
```


Compose another Reactor into this one.

Allows place another Reactor into this one as if it were a single step.


### Nested DSLs
 * [argument](#reactor-compose-argument)
 * [wait_for](#reactor-compose-wait_for)




### Arguments

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-reactor-reactor" href="#name-reactor-reactor">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        reactor
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor | module</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The reactor module or struct to compose upon.

  </td>
</tr>

  </tbody>
</table>
### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-reactor-name" href="#name-reactor-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the step. Allows the result of the composed reactor to be depended upon by steps in this reactor.

  </td>
</tr>

  </tbody>
</table>


## reactor.compose.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-source-name" href="#name-source-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-source" href="#name-source-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-transform" href="#name-source-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.compose.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="names-names" href="#names-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">list(atom) | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Compose`

## reactor.debug
```elixir
debug name
```


Inserts a step which will send debug information to the `Logger`.


### Nested DSLs
 * [argument](#reactor-debug-argument)
 * [wait_for](#reactor-debug-wait_for)


### Examples
```
debug :debug do
  argument :suss, result(:suss_step)
end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-name" href="#name-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique identifier for the step.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-level" href="#name-level">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        level
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">:emergency | :alert | :critical | :error | :warning | :notice | :info | :debug</code>
  </td>
  <td style="text-align: left">
    <code class="inline">:debug</code>
  </td>
  <td style="text-align: left" colspan=2>
    The log level to send the debug information to.

  </td>
</tr>

  </tbody>
</table>


## reactor.debug.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-source-name" href="#name-source-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-source" href="#name-source-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-transform" href="#name-source-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.debug.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="names-names" href="#names-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">list(atom) | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Debug`

## reactor.group
```elixir
group name
```


Call functions before and after a group of steps.


### Nested DSLs
 * [argument](#reactor-group-argument)
 * [wait_for](#reactor-group-wait_for)





### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-name" href="#name-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the group of steps.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-before_all" href="#name-before_all">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        before_all
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The before function. See `Reactor.Step.Group` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-after_all" href="#name-after_all">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        after_all
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The after function. See `Reactor.Step.Group` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-allow_async?" href="#name-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

  </tbody>
</table>


## reactor.group.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-source-name" href="#name-source-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-source" href="#name-source-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-transform" href="#name-source-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.group.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="names-names" href="#names-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">list(atom) | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Group`

## reactor.input
```elixir
input name
```


Specifies an input to the Reactor.

An input is a value passed in to the Reactor when executing.
If a Reactor were a function, these would be it's arguments.

Inputs can be transformed with an arbitrary function before being passed
to any steps.




### Examples
```
input :name

```

```
input :age do
  transform &String.to_integer/1
end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-name" href="#name-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for this input. Used to allow steps to depend on it.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-transform" href="#name-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the input before it is passed to any steps.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Input`

## reactor.iterate
```elixir
iterate name
```


Repeatedly execute a group of steps by emitting values from a generator
and consolidate their results with a reducer.

For more information about the semantics of the iterate step see the
`Reactor.Step.Iterate` moduledocs.


### Nested DSLs
 * [argument](#reactor-iterate-argument)
 * [wait_for](#reactor-iterate-wait_for)
 * [for_each](#reactor-iterate-for_each)
 * [map](#reactor-iterate-map)

 * [reduce](#reactor-iterate-reduce)
 * [source](#reactor-iterate-source)


### Examples
```
# Iterate over a string, reversing every word using manual iteration.

iterate :reverse_words do
  argument :words, input(:words)

  source do
    initialiser fn args ->
      {:ok, args.words}
    end

    generator fn words ->
      case String.split(words, ~r/ +/, parts: 2, trim: true) do
        [] -> {:halt, ""}
        [word] -> {:cont, [%{word: word}], ""}
        [word, remaining] -> {:cont, [%{word: word}], remaining}
      end
    end
  end

  map do
    step :reverse_word do
      argument :word, element(:word)

      run fn %{word: word} ->
        {:ok, String.reverse(word)}
      end
    end
  end

  reduce do
    accumulator fn ->
      {:ok, []}
    end

    reducer fn word, acc ->
      {:cont, [word | acc]}
    end

    finaliser fn words ->
      {:ok, Enum.reverse(words)}
    end
  end
end

```

```
# Summing an enumerable.

iterate :sum do
  argument :numbers, input(:numbers)

  for_each do
    source :numbers
    as :number
  end

  reduce do
    accumulator value(0)
    reducer &{:ok, &1 + &2}
  end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-name" href="#name-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for this step.
  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-async?" href="#name-async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    Allow the iteration to perform steps asynchronously.
  </td>
</tr>

  </tbody>
</table>


## reactor.iterate.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-source-name" href="#name-source-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-source" href="#name-source-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-transform" href="#name-source-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.iterate.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="names-names" href="#names-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">list(atom) | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.WaitFor`

## reactor.iterate.for_each


Given an input which implements Elixir's `Enumerable` protocol use it as
the source for the iteration.




### Examples
```
for_each do
  source :numbers
  as: :number
end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="as" href="#as">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        as
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name to use for each value in the element map.
  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="source" href="#source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of an argument provided to the parent `iterate` step.
  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Iterate.ForEach`

## reactor.iterate.map


The steps to run for each iteration.







### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="return" href="#return">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        return
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">nil | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Use result of the named step as the return value.
  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Iterate.Map`

## reactor.iterate.reduce


Reduces the results into a single value.

Similar in semantics to `Enum.reduce_while/3`, the `reduce` entity is
responsible for collecting results into a single value which will be the
result of the iterate step.

#### Accumulator

The accumulator function defines the value for the accumulator for the
first reduction (or if iteration halts without any reduction).

It can be initialised from an argument to the iterate step if needed.

#### Reducer

The reducer function takes the result of a previous map operation and
uses it to generate a new accumulator value.

#### Finaliser

When the iterator halts iteration, the finaliser is called with allows
you to perform a final operation on the accumulator before it is
returned.

> #### Warning {: .tip}
>
> You should not assume that these functions will all be called within
> the same process, as they may be run asynchronously depending on the
> configuration of the Reactor.




### Examples
```
reduce do
  accumulator fn -> {:ok, %{}} end

  reducer fn word, counts ->
    {:cont, Map.update(counts, word, 1, &(&1 + 1))}
  end
end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="accumulator" href="#accumulator">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        accumulator
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any -> any) | mfa | (any -> any) | mfa | (-> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The initial accumulator value.
  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="reducer" href="#reducer">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        reducer
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any, any -> any) | mfa | (any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A function which reduces values into an accumulator.
  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="finaliser" href="#finaliser">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        finaliser
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">nil | (any, any -> any) | mfa | (any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional final transformation function.
  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Iterate.Reduce`

## reactor.iterate.source


Provides the source of an iteration by lazily generating elements.

Similar in semantics to `Stream.resource/3`, the `source` entity is
responsible for generating values for use in iteration.

#### Initialiser

The initialiser is responsible for taking the arguments provided to the
`iterate` step and returning a term which can be used as the input to the
generator.

You could use this to open a file for reading, or access an API endpoint.

#### Generator

The generator function takes the state from the initialiser and uses it
to generate the next value(s) to map and reduce.

Each element must be a map which can be accessed with the
`element/1` helper.

If your function returns more than one element the elements will be
buffered inside the iterator.

Your generator function will be called repeatedly until it returns a
`:halt` tuple - even if it returns no elements.

#### Finaliser

When the generator halts iteration then the finaliser is called which
allows you to clean up any resources in use if required.

> #### Warning {: .tip}
>
> You should not assume that these functions will all be called within
> the same process, as they may be run asynchronously depending on the
> configuration of the Reactor.




### Examples
```
source do
  initialiser fn args ->
    File.open(args.file, [:read])
  end

  generator fn file ->
    case IO.read(file, :line) do
      :eof -> {:halt, file}
      {:error, reason} -> {:error, reason}
      data -> {:cont, [%{line: data}], file}
    end
  end

  finaliser fn file ->
    File.close(file)
  end
end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="generator" href="#generator">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        generator
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any -> any) | mfa | (any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A function which emits the next value(s) for the iteration.
  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="initialiser" href="#initialiser">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        initialiser
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any, any -> any) | mfa | (any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A function which initialises the generator state.
  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="finaliser" href="#finaliser">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        finaliser
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">nil | (any, any -> any) | mfa | (any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional clean up function.
  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Iterate.Source`




### Introspection

Target: `Reactor.Dsl.Iterate`

## reactor.step
```elixir
step name, impl \ nil
```


Specifies a Reactor step.

Steps are the unit of work in a Reactor.  Reactor will calculate the
dependencies graph between the steps and execute as many as it can in each
iteration.

See the `Reactor.Step` behaviour for more information.


### Nested DSLs
 * [argument](#reactor-step-argument)
 * [wait_for](#reactor-step-wait_for)


### Examples
```
step :create_user, MyApp.Steps.CreateUser do
  argument :username, input(:username)
  argument :password_hash, result(:hash_password)
end

```

```
step :hash_password do
  argument :password, input(:password)

  run fn %{password: password}, _ ->
    {:ok, Bcrypt.hash_pwd_salt(password)}
  end
end

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-impl-name" href="#name-impl-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-impl-impl" href="#name-impl-impl">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        impl
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A module that implements the `Reactor.Step` behaviour that provides the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-impl-run" href="#name-impl-run">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        run
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa | (any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Provide an anonymous function which implements the `run/3` callback. Cannot be provided at the same time as the `impl` argument.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-impl-undo" href="#name-impl-undo">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        undo
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa | (any, any -> any) | mfa | (any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-impl-compensate" href="#name-impl-compensate">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        compensate
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa | (any, any -> any) | mfa | (any, any, any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-impl-max_retries" href="#name-impl-max_retries">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        max_retries
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">:infinity | non_neg_integer</code>
  </td>
  <td style="text-align: left">
    <code class="inline">:infinity</code>
  </td>
  <td style="text-align: left" colspan=2>
    The maximum number of times that the step can be retried before failing. Only used when the result of the `compensate/4` callback is `:retry`.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-impl-async?" href="#name-impl-async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-impl-transform" href="#name-impl-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the entire argument map before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>


## reactor.step.argument
```elixir
argument name, source \ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-source-name" href="#name-source-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the argument which will be used as the key in the `arguments` map passed to the implementation.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-source" href="#name-source-source">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        source
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-source-transform" href="#name-source-transform">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        transform
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | module | nil</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    An optional transformation function which can be used to modify the argument before it is passed to the step.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.step.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```




### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="names-names" href="#names-names">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        names
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">list(atom) | atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The name of the step to wait for.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Step`

## reactor.switch
```elixir
switch name
```


Use a predicate to determine which steps should be executed.


### Nested DSLs
 * [matches?](#reactor-switch-matches?)

 * [default](#reactor-switch-default)






### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="name-name" href="#name-name">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        name
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A unique name for the switch.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-on" href="#name-on">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        on
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    The value to match against.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="name-allow_async?" href="#name-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

  </tbody>
</table>


## reactor.switch.matches?
```elixir
matches? predicate
```


A group of steps to run when the predicate matches.







### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="predicate-predicate" href="#predicate-predicate">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        predicate
      </span>
    </a>
      <sup style="color: red">*</sup>

  </td>
  <td style="text-align: left">
    <code class="inline">(any -> any) | mfa</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    A one-arity function which is used to match the switch input. If the switch returns a truthy value, then the nested steps will be run.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="predicate-allow_async?" href="#predicate-allow_async?">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        allow_async?
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">boolean</code>
  </td>
  <td style="text-align: left">
    <code class="inline">true</code>
  </td>
  <td style="text-align: left" colspan=2>
    Whether the emitted steps should be allowed to run asynchronously.

  </td>
</tr>

<tr>
  <td style="text-align: left">
    <a id="predicate-return" href="#predicate-return">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        return
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Specify which step result to return upon completion.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Switch.Match`

## reactor.switch.default


If none of the `matches?` branches match the input, then the `default`
steps will be run if provided.







### Options

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th colspan=2>Docs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
  <td style="text-align: left">
    <a id="return" href="#return">
      <span style="font-family: Inconsolata, Menlo, Courier, monospace;">
        return
      </span>
    </a>
      
  </td>
  <td style="text-align: left">
    <code class="inline">atom</code>
  </td>
  <td style="text-align: left">
    
  </td>
  <td style="text-align: left" colspan=2>
    Specify which step result to return upon completion.

  </td>
</tr>

  </tbody>
</table>





### Introspection

Target: `Reactor.Dsl.Switch.Default`




### Introspection

Target: `Reactor.Dsl.Switch`




