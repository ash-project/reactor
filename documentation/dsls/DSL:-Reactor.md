<!--
This file was generated by Spark. Do not edit it by hand.
-->
# DSL: Reactor.Dsl



## reactor
The top-level reactor DSL

### Nested DSLs
 * [around](#reactor-around)
   * argument
   * wait_for
 * [collect](#reactor-collect)
   * argument
   * wait_for
 * [compose](#reactor-compose)
   * argument
   * wait_for
 * [debug](#reactor-debug)
   * argument
   * wait_for
 * [group](#reactor-group)
   * argument
   * wait_for
 * [input](#reactor-input)
 * [iterate](#reactor-iterate)
   * argument
   * wait_for
   * for_each
   * map

   * reduce
   * source
 * [step](#reactor-step)
   * argument
   * wait_for
 * [switch](#reactor-switch)
   * matches?

   * default






### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`return`](#reactor-return){: #reactor-return } | `atom` |  | Specify which step result to return upon completion. |



## reactor.around
```elixir
around name, fun \\ nil
```


Wrap a function around a group of steps.


### Nested DSLs
 * [argument](#reactor-around-argument)
 * [wait_for](#reactor-around-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-around-name){: #reactor-around-name .spark-required} | `atom` |  | A unique name of the group of steps. |
| [`fun`](#reactor-around-fun){: #reactor-around-fun .spark-required} | `(any, any, any, any -> any) \| mfa` |  | The around function. See `Reactor.Step.Around` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`allow_async?`](#reactor-around-allow_async?){: #reactor-around-allow_async? } | `boolean` | `false` | Whether the emitted steps should be allowed to run asynchronously. |


## reactor.around.argument
```elixir
argument name, source \\ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-around-argument-name){: #reactor-around-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| [`source`](#reactor-around-argument-source){: #reactor-around-argument-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-around-argument-transform){: #reactor-around-argument-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.around.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-around-wait_for-names){: #reactor-around-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Around`

## reactor.collect
```elixir
collect name
```


A Reactor step which simply collects and returns it's arguments.

Arguments can optionally be transformed before returning.


### Nested DSLs
 * [argument](#reactor-collect-argument)
 * [wait_for](#reactor-collect-wait_for)


### Examples
```
collect :latest_release_uri do
  argument :repository, input(:repository)
  argument :organisation, input(:organisation)

  transform fn inputs ->
    %{uri: "https://api.github.com/repos/#{inputs.organisation}/#{inputs.repository}/releases/latest"}
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-collect-name){: #reactor-collect-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-collect-transform){: #reactor-collect-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the entire argument map before it is returned. |


## reactor.collect.argument
```elixir
argument name, source \\ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-collect-argument-name){: #reactor-collect-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| [`source`](#reactor-collect-argument-source){: #reactor-collect-argument-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-collect-argument-transform){: #reactor-collect-argument-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.collect.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-collect-wait_for-names){: #reactor-collect-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Collect`

## reactor.compose
```elixir
compose name, reactor
```


Compose another Reactor into this one.

Allows place another Reactor into this one as if it were a single step.


### Nested DSLs
 * [argument](#reactor-compose-argument)
 * [wait_for](#reactor-compose-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-compose-name){: #reactor-compose-name .spark-required} | `atom` |  | A unique name for the step. Allows the result of the composed reactor to be depended upon by steps in this reactor. |
| [`reactor`](#reactor-compose-reactor){: #reactor-compose-reactor .spark-required} | `Reactor \| module` |  | The reactor module or struct to compose upon. |



## reactor.compose.argument
```elixir
argument name, source \\ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-compose-argument-name){: #reactor-compose-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| [`source`](#reactor-compose-argument-source){: #reactor-compose-argument-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-compose-argument-transform){: #reactor-compose-argument-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.compose.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-compose-wait_for-names){: #reactor-compose-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Compose`

## reactor.debug
```elixir
debug name
```


Inserts a step which will send debug information to the `Logger`.


### Nested DSLs
 * [argument](#reactor-debug-argument)
 * [wait_for](#reactor-debug-wait_for)


### Examples
```
debug :debug do
  argument :suss, result(:suss_step)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-debug-name){: #reactor-debug-name .spark-required} | `atom` |  | A unique identifier for the step. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`level`](#reactor-debug-level){: #reactor-debug-level } | `:emergency \| :alert \| :critical \| :error \| :warning \| :notice \| :info \| :debug` | `:debug` | The log level to send the debug information to. |


## reactor.debug.argument
```elixir
argument name, source \\ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-debug-argument-name){: #reactor-debug-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| [`source`](#reactor-debug-argument-source){: #reactor-debug-argument-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-debug-argument-transform){: #reactor-debug-argument-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.debug.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-debug-wait_for-names){: #reactor-debug-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Debug`

## reactor.group
```elixir
group name
```


Call functions before and after a group of steps.


### Nested DSLs
 * [argument](#reactor-group-argument)
 * [wait_for](#reactor-group-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-group-name){: #reactor-group-name .spark-required} | `atom` |  | A unique name for the group of steps. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`before_all`](#reactor-group-before_all){: #reactor-group-before_all .spark-required} | `(any, any, any -> any) \| mfa` |  | The before function. See `Reactor.Step.Group` for more information. |
| [`after_all`](#reactor-group-after_all){: #reactor-group-after_all .spark-required} | `(any, any, any -> any) \| mfa` |  | The after function. See `Reactor.Step.Group` for more information. |
| [`allow_async?`](#reactor-group-allow_async?){: #reactor-group-allow_async? } | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |


## reactor.group.argument
```elixir
argument name, source \\ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-group-argument-name){: #reactor-group-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| [`source`](#reactor-group-argument-source){: #reactor-group-argument-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-group-argument-transform){: #reactor-group-argument-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.group.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-group-wait_for-names){: #reactor-group-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Group`

## reactor.input
```elixir
input name
```


Specifies an input to the Reactor.

An input is a value passed in to the Reactor when executing.
If a Reactor were a function, these would be it's arguments.

Inputs can be transformed with an arbitrary function before being passed
to any steps.




### Examples
```
input :name

```

```
input :age do
  transform &String.to_integer/1
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-input-name){: #reactor-input-name .spark-required} | `atom` |  | A unique name for this input. Used to allow steps to depend on it. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-input-transform){: #reactor-input-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the input before it is passed to any steps. |





### Introspection

Target: `Reactor.Dsl.Input`

## reactor.iterate
```elixir
iterate name
```


Repeatedly execute a group of steps by emitting values from a generator
and consolidate their results with a reducer.

For more information about the semantics of the iterate step see the
`Reactor.Step.Iterate` moduledocs.


### Nested DSLs
 * [argument](#reactor-iterate-argument)
 * [wait_for](#reactor-iterate-wait_for)
 * [for_each](#reactor-iterate-for_each)
 * [map](#reactor-iterate-map)

 * [reduce](#reactor-iterate-reduce)
 * [source](#reactor-iterate-source)


### Examples
```
# Iterate over a string, reversing every word using manual iteration.

iterate :reverse_words do
  argument :words, input(:words)

  source do
    initialiser fn args ->
      {:ok, args.words}
    end

    generator fn words ->
      case String.split(words, ~r/ +/, parts: 2, trim: true) do
        [] -> {:halt, ""}
        [word] -> {:cont, [%{word: word}], ""}
        [word, remaining] -> {:cont, [%{word: word}], remaining}
      end
    end
  end

  map do
    step :reverse_word do
      argument :word, element(:word)

      run fn %{word: word} ->
        {:ok, String.reverse(word)}
      end
    end
  end

  reduce do
    accumulator fn ->
      {:ok, []}
    end

    reducer fn word, acc ->
      {:cont, [word | acc]}
    end

    finaliser fn words ->
      {:ok, Enum.reverse(words)}
    end
  end
end

```

```
# Summing an enumerable.

iterate :sum do
  argument :numbers, input(:numbers)

  for_each do
    source :numbers
    as :number
  end

  reduce do
    accumulator value(0)
    reducer &{:ok, &1 + &2}
  end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-iterate-name){: #reactor-iterate-name .spark-required} | `atom` |  | A unique name for this step. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`async?`](#reactor-iterate-async?){: #reactor-iterate-async? } | `boolean` | `true` | Allow the iteration to perform steps asynchronously. |


## reactor.iterate.argument
```elixir
argument name, source \\ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-iterate-argument-name){: #reactor-iterate-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| [`source`](#reactor-iterate-argument-source){: #reactor-iterate-argument-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-iterate-argument-transform){: #reactor-iterate-argument-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.iterate.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-iterate-wait_for-names){: #reactor-iterate-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`

## reactor.iterate.for_each


Given an input which implements Elixir's `Enumerable` protocol use it as
the source for the iteration.




### Examples
```
for_each do
  source :numbers
  as: :number
end

```




### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`as`](#reactor-iterate-for_each-as){: #reactor-iterate-for_each-as .spark-required} | `atom` |  | The name to use for each value in the element map. |
| [`source`](#reactor-iterate-for_each-source){: #reactor-iterate-for_each-source .spark-required} | `atom` |  | The name of an argument provided to the parent `iterate` step. |





### Introspection

Target: `Reactor.Dsl.Iterate.ForEach`

## reactor.iterate.map


The steps to run for each iteration.







### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`return`](#reactor-iterate-map-return){: #reactor-iterate-map-return } | `nil \| atom` |  | Use result of the named step as the return value. |





### Introspection

Target: `Reactor.Dsl.Iterate.Map`

## reactor.iterate.reduce


Reduces the results into a single value.

Similar in semantics to `Enum.reduce_while/3`, the `reduce` entity is
responsible for collecting results into a single value which will be the
result of the iterate step.

#### Accumulator

The accumulator function defines the value for the accumulator for the
first reduction (or if iteration halts without any reduction).

It can be initialised from an argument to the iterate step if needed.

#### Reducer

The reducer function takes the result of a previous map operation and
uses it to generate a new accumulator value.

#### Finaliser

When the iterator halts iteration, the finaliser is called with allows
you to perform a final operation on the accumulator before it is
returned.

> #### Warning {: .tip}
>
> You should not assume that these functions will all be called within
> the same process, as they may be run asynchronously depending on the
> configuration of the Reactor.




### Examples
```
reduce do
  accumulator fn -> {:ok, %{}} end

  reducer fn word, counts ->
    {:cont, Map.update(counts, word, 1, &(&1 + 1))}
  end
end

```




### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`accumulator`](#reactor-iterate-reduce-accumulator){: #reactor-iterate-reduce-accumulator .spark-required} | `(any, any -> any) \| mfa \| (any -> any) \| mfa \| (-> any) \| mfa` |  | The initial accumulator value. |
| [`reducer`](#reactor-iterate-reduce-reducer){: #reactor-iterate-reduce-reducer .spark-required} | `(any, any, any -> any) \| mfa \| (any, any -> any) \| mfa` |  | A function which reduces values into an accumulator. |
| [`finaliser`](#reactor-iterate-reduce-finaliser){: #reactor-iterate-reduce-finaliser } | `nil \| (any, any -> any) \| mfa \| (any -> any) \| mfa` |  | An optional final transformation function. |





### Introspection

Target: `Reactor.Dsl.Iterate.Reduce`

## reactor.iterate.source


Provides the source of an iteration by lazily generating elements.

Similar in semantics to `Stream.resource/3`, the `source` entity is
responsible for generating values for use in iteration.

#### Initialiser

The initialiser is responsible for taking the arguments provided to the
`iterate` step and returning a term which can be used as the input to the
generator.

You could use this to open a file for reading, or access an API endpoint.

#### Generator

The generator function takes the state from the initialiser and uses it
to generate the next value(s) to map and reduce.

Each element must be a map which can be accessed with the
`element/1` helper.

If your function returns more than one element the elements will be
buffered inside the iterator.

Your generator function will be called repeatedly until it returns a
`:halt` tuple - even if it returns no elements.

#### Finaliser

When the generator halts iteration then the finaliser is called which
allows you to clean up any resources in use if required.

> #### Warning {: .tip}
>
> You should not assume that these functions will all be called within
> the same process, as they may be run asynchronously depending on the
> configuration of the Reactor.




### Examples
```
source do
  initialiser fn args ->
    File.open(args.file, [:read])
  end

  generator fn file ->
    case IO.read(file, :line) do
      :eof -> {:halt, file}
      {:error, reason} -> {:error, reason}
      data -> {:cont, [%{line: data}], file}
    end
  end

  finaliser fn file ->
    File.close(file)
  end
end

```




### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`generator`](#reactor-iterate-source-generator){: #reactor-iterate-source-generator .spark-required} | `(any, any -> any) \| mfa \| (any -> any) \| mfa` |  | A function which emits the next value(s) for the iteration. |
| [`initialiser`](#reactor-iterate-source-initialiser){: #reactor-iterate-source-initialiser .spark-required} | `(any, any -> any) \| mfa \| (any -> any) \| mfa` |  | A function which initialises the generator state. |
| [`finaliser`](#reactor-iterate-source-finaliser){: #reactor-iterate-source-finaliser } | `nil \| (any, any -> any) \| mfa \| (any -> any) \| mfa` |  | An optional clean up function. |





### Introspection

Target: `Reactor.Dsl.Iterate.Source`




### Introspection

Target: `Reactor.Dsl.Iterate`

## reactor.step
```elixir
step name, impl \\ nil
```


Specifies a Reactor step.

Steps are the unit of work in a Reactor.  Reactor will calculate the
dependencies graph between the steps and execute as many as it can in each
iteration.

See the `Reactor.Step` behaviour for more information.


### Nested DSLs
 * [argument](#reactor-step-argument)
 * [wait_for](#reactor-step-wait_for)


### Examples
```
step :create_user, MyApp.Steps.CreateUser do
  argument :username, input(:username)
  argument :password_hash, result(:hash_password)
end

```

```
step :hash_password do
  argument :password, input(:password)

  run fn %{password: password}, _ ->
    {:ok, Bcrypt.hash_pwd_salt(password)}
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-step-name){: #reactor-step-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps. |
| [`impl`](#reactor-step-impl){: #reactor-step-impl } | `module \| nil` |  | A module that implements the `Reactor.Step` behaviour that provides the implementation. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`run`](#reactor-step-run){: #reactor-step-run } | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide an anonymous function which implements the `run/3` callback. Cannot be provided at the same time as the `impl` argument. |
| [`undo`](#reactor-step-undo){: #reactor-step-undo } | `(any -> any) \| mfa \| (any, any -> any) \| mfa \| (any, any, any -> any) \| mfa` |  | Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument. |
| [`compensate`](#reactor-step-compensate){: #reactor-step-compensate } | `(any -> any) \| mfa \| (any, any -> any) \| mfa \| (any, any, any -> any) \| mfa` |  | Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument. |
| [`max_retries`](#reactor-step-max_retries){: #reactor-step-max_retries } | `:infinity \| non_neg_integer` | `:infinity` | The maximum number of times that the step can be retried before failing. Only used when the result of the `compensate/4` callback is `:retry`. |
| [`async?`](#reactor-step-async?){: #reactor-step-async? } | `boolean` | `true` | When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`. |
| [`transform`](#reactor-step-transform){: #reactor-step-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the entire argument map before it is passed to the step. |


## reactor.step.argument
```elixir
argument name, source \\ nil
```


Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before
being passed to any steps.




### Examples
```
argument :name, input(:name)

```

```
argument :year, input(:date, [:year])

```

```
argument :user, result(:create_user)

```

```
argument :user_id, result(:create_user) do
  transform & &1.id
end

```

```
argument :user_id, result(:create_user, [:id])

```

```
argument :three, value(3)

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-step-argument-name){: #reactor-step-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |
| [`source`](#reactor-step-argument-source){: #reactor-step-argument-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`transform`](#reactor-step-argument-transform){: #reactor-step-argument-transform } | `(any -> any) \| module \| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |





### Introspection

Target: `Reactor.Dsl.Argument`

## reactor.step.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-step-wait_for-names){: #reactor-step-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Dsl.Step`

## reactor.switch
```elixir
switch name
```


Use a predicate to determine which steps should be executed.


### Nested DSLs
 * [matches?](#reactor-switch-matches?)

 * [default](#reactor-switch-default)





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-switch-name){: #reactor-switch-name .spark-required} | `atom` |  | A unique name for the switch. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`on`](#reactor-switch-on){: #reactor-switch-on .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The value to match against. |
| [`allow_async?`](#reactor-switch-allow_async?){: #reactor-switch-allow_async? } | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |


## reactor.switch.matches?
```elixir
matches? predicate
```


A group of steps to run when the predicate matches.






### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-switch-matches?-predicate){: #reactor-switch-matches?-predicate .spark-required} | `(any -> any) \| mfa` |  | A one-arity function which is used to match the switch input. If the switch returns a truthy value, then the nested steps will be run. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`allow_async?`](#reactor-switch-matches?-allow_async?){: #reactor-switch-matches?-allow_async? } | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |
| [`return`](#reactor-switch-matches?-return){: #reactor-switch-matches?-return } | `atom` |  | Specify which step result to return upon completion. |





### Introspection

Target: `Reactor.Dsl.Switch.Match`

## reactor.switch.default


If none of the `matches?` branches match the input, then the `default`
steps will be run if provided.







### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`return`](#reactor-switch-default-return){: #reactor-switch-default-return } | `atom` |  | Specify which step result to return upon completion. |





### Introspection

Target: `Reactor.Dsl.Switch.Default`




### Introspection

Target: `Reactor.Dsl.Switch`





<style type="text/css">.spark-required::after { content: "*"; color: red !important; }</style>
